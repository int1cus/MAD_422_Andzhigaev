Задача 1.
Условие:
Напишите программу, в которой:

Есть общий счётчик (Counter).
5 потоков одновременно увеличивают его значение на 1 в цикле 1000 раз каждый.
Цель:
Используйте synchronized или ReentrantLock, чтобы обеспечить корректное значение счётчика.

Задача 2: Генерация последовательности чисел
Условие:
Создайте программу, которая:

Имеет общий список чисел.
10 потоков одновременно добавляют в этот список числа от 1 до 100.
Используйте потокобезопасную коллекцию, например, CopyOnWriteArrayList или ConcurrentLinkedQueue.
Цель:
Обеспечить потокобезопасное добавление чисел в общий список.

Задача 3: Распределение задач с использованием пула потоков
Условие:
Напишите программу, которая:

Создаёт пул из 4 потоков (ExecutorService).
Выполняет 20 задач, каждая из которых просто выводит имя потока и номер задачи.
Цель:
Использовать пул потоков для распределения задач между потоками.

Задача 4: Симуляция работы банка
Условие:
Создайте программу для работы банка, где:

Есть несколько аккаунтов с начальным балансом.
Несколько потоков выполняют операции перевода денег между аккаунтами.
Операции перевода должны быть потокобезопасными.
Цель:
Реализуйте потокобезопасную операцию перевода с использованием synchronized или ReentrantLock.

Задача 5: Барьер синхронизации
Условие:
Используйте CyclicBarrier для создания программы, где:

5 потоков выполняют свои задачи.
Когда все потоки завершают свои задачи, они ждут друг друга, чтобы перейти к следующей фазе работы.
Цель:
Изучить использование CyclicBarrier для синхронизации работы потоков.

Задача 6: Ограниченный доступ к ресурсу
Условие:
Создайте программу, где:

Есть ресурс, доступный одновременно только для двух потоков.
Используйте Semaphore для ограничения доступа.
Цель:
Ограничить количество потоков, которые одновременно получают доступ к ресурсу.

Задача 7: Обработка результатов задач
Условие:
Создайте программу, где:

10 потоков выполняют расчёт (например, вычисление факториала числа).
Каждый поток возвращает результат через Callable и Future.
Цель:
Изучить механизм возврата результатов из потоков с использованием Callable и Future.


Задача 8: Симуляция производственной линии
Условие:
Создайте программу, где:

Один поток выполняет "производство" данных и добавляет их в BlockingQueue.
Другой поток забирает данные из очереди и "обрабатывает" их (например, выводит в консоль).
Цель:
Используйте BlockingQueue для организации взаимодействия между потоками.


Задача 9: Многопоточная сортировка
Условие:
Реализуйте программу, которая:

Делит массив чисел на части.
Каждая часть сортируется в отдельном потоке.
Затем отсортированные части объединяются в один массив.
Цель:
Научиться использовать многопоточность для параллельной обработки данных.


Задача 10: Обед философов (*)
Условие:
Реализуйте программу, где:

Пять философов сидят за круглым столом.
Каждый философ ест, если у него есть обе вилки (левая и правая).
Вилки являются общими для двух соседних философов.
Цель:
Избежать взаимной блокировки (deadlock) при использовании общих ресурсов.


Задача 11: Расчёт матрицы в параллельных потоках
Условие:
Реализуйте программу для параллельного умножения двух матриц:

Каждый поток вычисляет результат для одной строки итоговой матрицы.
Цель:
Использовать многопоточность для ускорения вычислений.


Задача 12: Таймер с многопоточностью
Условие:
Создайте программу, где:

Один поток запускает таймер, который каждую секунду выводит время.
Второй поток через 10 секунд останавливает таймер.
Цель:
Научиться управлять работой потоков.
